{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f4\froman\fcharset0\fprq2{\*\panose 120088061300f4c91200}Times;}{\f397\froman\fcharset238\fprq2 Times New Roman CE;}{\f398\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f400\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f401\froman\fcharset162\fprq2 Times New Roman Tur;}{\f402\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f403\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f404\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f413\fmodern\fcharset238\fprq1 Courier New CE;}{\f414\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f416\fmodern\fcharset161\fprq1 Courier New Greek;}{\f417\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f418\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f419\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f420\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f429\froman\fcharset238\fprq2 Times CE;}{\f430\froman\fcharset204\fprq2 Times Cyr;}
{\f432\froman\fcharset161\fprq2 Times Greek;}{\f433\froman\fcharset162\fprq2 Times Tur;}{\f434\froman\fcharset177\fprq2 Times (Hebrew);}{\f435\froman\fcharset178\fprq2 Times (Arabic);}{\f436\froman\fcharset186\fprq2 Times Baltic;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \snext0 Normal;}{\s1\qr \li0\ri0\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs16\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \sbasedon0 \snext0 heading 1;}{\*\cs10 
\additive Default Paragraph Font;}{\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f4\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \sbasedon0 \snext15 Body Text;}{
\s16\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f2\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \sbasedon0 \snext16 Body Text 2;}{\s17\ql \li0\ri0\widctlpar
\tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \sbasedon0 \snext17 header;}{\s18\ql \li0\ri0\widctlpar
\tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 \sbasedon0 \snext18 footer;}{\*\cs19 \additive \sbasedon10 page number;}}{\info{\title MsgAPI Documentation, Revision 0}
{\author Scott J. Dudley}{\operator andrew clarke}{\creatim\yr2002\mo11\dy11\hr2\min8}{\revtim\yr2002\mo11\dy11\hr2\min8}{\printim\yr2002\mo11\dy11\hr1\min59}{\version2}{\edmins1}{\nofpages9}{\nofwords3835}{\nofchars19561}{\*\company Lanius Corporation}
{\nofcharsws26848}{\vern8269}}\paperw11906\paperh16838\margl1134\margr1134\margt1134\margb1134 \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1134\dgvorigin1134
\dghshow1\dgvshow1\jexpand\viewkind5\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0{\*\docvar {_ExportToHTMLPath}{E:\'5cwip\'5cmsgapi\'5cMsgAPI.htm}}\sectd 
\linex0\headery709\footery709\colsx708\endnhere\sectlinegrid360\sectdefaultcl {\footer \pard\plain \s18\ql \li0\ri0\widctlpar\tqc\tx4153\tqr\tx8306\pvpara\phmrg\posxr\posy0\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\field{\*\fldinst {\cs19 PAGE  }}{\fldrslt {\cs19\lang1024\langfe1024\noproof 1}}}{\cs19 
\par }\pard\plain \s1\qr \li0\ri360\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin360\lin0\itap0 \b\fs16\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {MsgAPI Documentation, Revision 0
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\f4\fs20 
\par 
\par 
\par }{\b\f4 MsgAPI Documentation, Revision 0
\par 
\par Copyright 1990, 1991 by Scott J. Dudley.  All rights reserved.
\par 
\par Function Reference}{\f4 
\par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f4\fs20 \page }{\b\f2\fs20 sword MsgOpenApi(struct _minf *minf);
\par }{\f4\fs20 
\par The MsgOpenApi function is used to initialize the MsgAPI. This function must be called before an
y of the other API functions are called, or else the results are undefined.  This function serves to initialize any needed structures, and to prepare the message bases for use.  This function's accepts one arguments: a pointer to a structure containing in
formation about the application.  The contents of this structure as as follows:
\par 
\par }{\b\f2\fs20 struct _minf
\par \{
\par     word req_version;
\par     word def_zone;
\par     word _haveshare;
\par \};
\par }{\f4\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f4\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {`req_version' indicates the MsgAPI revision level that the application is requesting.  The comp
ile-time revision level can always be accessed using the constant `MSGAPI_VERSION'.
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\f4\fs20 
\par `def_zone' should contain a default FidoNet zone number.  Certain message systems, such as the FTSC-0001 *.MSG format, do not store zone information with each message.  Wh
en the API encounters such a message and no zone is present, the specified zone will be used instead.  A `def_zone' of 0 indicates that nothing is to be inferred about the zone number of a message, and in that case, the API functions will return 0 as the 
zone number for any message with an unknown zone.
\par 
\par `_haveshare' is automatically filled in by the internal API routines, and this flag indicates whether or not the DOS "SHARE.EXE" program is currently loaded.  Note that SHARE must always be loaded to access
 Squish-format bases in a multitasking or network environment. 
\par 
\par MsgOpenApi() returns a value of 0 if the initialization was performed successfully, and -1 if a problem was encountered.
\par 
\par {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}
\par 
\par }{\b\f2\fs20 sword MsgCloseApi(void);
\par }{\f4\fs20 
\par This function is used to denationalize the MsgAPI.  This function performs any clean-up actions which may be necessary, including the closing of files and releasing allocated memory.  This function should be called before the application terminates.

\par 
\par MsgCloseApi returns a value of 0 if the API was successfully deinitialized, and -1 otherwise.
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1026{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par }{\b\f2\fs20 
\par MSG * MsgOpenArea(byte *name, word mode, word type);
\par }{\f4\fs20 
\par This function is used to open or create a message area.  This function accepts three parameters:
\par 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f4\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {`name' is the name of the message area to open.  Th
e contents of this string are implementation-defined.  (See `type' for more information.) 
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\f4\fs20 
\par `mode' is the mode with which the area should be opened. Values for `mode' are as follows:
\par 
\par MSGAREA_NORMAL  - Open the message area in a normal access mode.  If the area does not exist, this function fails.
\par 
\par MSGAREA_CRIFNEC - Open the message area in a normal access mode.  If the area does not exist, the MsgAPI attempts to create the area.  If the area cannot be created, this function fails.
\par 
\par MSGAREA_CREATE - Create the message area.  If the area already exists, it is truncated or started anew with no messages.  If the area cannot be created, this function fails.
\par 
\par `type' specifies the type of message area to open.  `type' can have any of the following values:
\par 
\par MSGTYPE
_SDM - Star Dot MSG (SDM).  This specifies a FTSC-0001 compatible access mode, and it instructs the MsgAPI to create and read Fido-compatible messages for this area.  If MSGTYPE_SDM is specified, `name' should contain the path to the *.MSG directory.

\par 
\par MSGTYPE_SQUISH - Squish (*.SQ?) format.  This specifies that the proprietary Squish message format is to be used for this area.  `name' should give the path and root name (eight characters) for the message area.
\par 
\par In addition, if the mask `MSGTYPE_ECHO' is bitw
ise ORed with the `MSGTYPE_SDM' value, the area in question will be treated as a FidoNet-style echomail area.  This instructs the MsgAPI to keep high-water mark information in the 1.MSG file, and to stop the normal MsgAPI functions from writing to the fir
st message in each area.  Other message formats have a cleaner way of storing the high-water mark, so this mask is only required for *.MSG areas.
\par 
\par Other values for `type' are currently reserved.
\par 
\par If this function succeeds in opening the message area, a hand
le is returned in the form of a pointer to a MSG structure.  This structure does not contain any information which can be used by the caller; all interaction should be performed through the MsgAPI functions only. 
\par 
\par If this function fails, NULL is returned, and the global `msgapierr' variable is set to one of the following values:
\par 
\par MERR_NOMEM - Not enough memory for requested task
\par 
\par MERR_NOENT - The area did not exist or could not be created.
\par 
\par MERR_BADF - The message area is structurally damaged.
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1027{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgCloseArea(MSG *mh);
\par }{\f4\fs20 
\par This function serves to "close" a message area.  This function performs all clean-up actions necessary, such as closing files, changing directories, and so on.  The function accepts one argument, which must be a MSG* handle returned b
y the MsgOpenArea function.  The MsgCloseArea function should be called for each area opened by MsgOpenArea. 
\par 
\par If the area was successfully closed, MsgCloseArea returns 0.  Otherwise, a value of -1 is returned and msgapierr is set to one of the following: 
\par 
\par MERR_BADH - An invalid handle was passed to the function.
\par 
\par MERR_EOPEN - Messages are still "open" in this area, so the area could not be closed.
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1028{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 MSGH * MsgOpenMsg(MSG *mh, word mode, dword msgn);
\par }{\f4\fs20 
\par This function "opens" a message for access, and it must be used to read from or write to a given message.  The function accepts three arguments: 
\par 
\par `mh' is a message area handle, as returned by the MsgOpenArea function. 
\par 
\par `mode' is an access flag, containing one of the following manifest constants:
\par 
\par MOPEN_CREATE - Create a new message.  This mode should only be used for creating new messages.
\par 
\par MOPEN_READ - Open an existing message for reading ONLY.
\par 
\par MOPEN_WRITE - Open an existing message for writing ONLY.
\par 
\par MOPEN_RW - Open an existing message for reading AND writing.
\par 
\par `msgn' is the specified message number to open.  If mode is either MOPEN_READ, MOPEN_WRITE or MOPEN_RW, the message number must currently exist in the specified area.  If mode is set to MOPEN_CREATE, a value of 0 for `msgn' indicates that a new mes
sage should be created, and assigned a number one higher than the current highest message.  If `msgn' is non-zero, but MOPEN_CREATE is set to the number of a currently-existing message, the specified message will be truncated and the new message will take
 its place.
\par 
\par For MOPEN_READ or MOPEN_RW, the following constants can also be passed in place of `msgn':
\par 
\par MSGNUM_CUR - Open the last message which was accessed by MsgOpenMsg. 
\par 
\par MSGNUM_PREV - Open the message prior to the last message accessed by MsgOpenMsg.
\par 
\par MSGNUM_NEXT - Open the message after the last message accessed by MsgOpenMsg.
\par 
\par The MsgAPI maintains the number of last message message opened by MsgOpenMsg, which is used when processing these constants.  (See also MsgGetCurMsg.)
\par 
\par If the message was successfully opened, the MsgOpenMsg function will return a pointer to a MSGH structure.  Otherwise, a value of NULL is returned, and msgapierr will be set to one of the following:
\par 
\par MERR_NOENT
\par MERR_NOMEM
\par MERR_BADF
\par MERR_BADA
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1029{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgCloseMsg(MSGH *msgh);
\par }{\f4\fs20 
\par The MsgCloseMsg function serves to "close" a message which has been previously opened by MsgOpenMsg.  All messages should be closed after use, or else data loss may result.
\par 
\par This function accepts a single argument, which is the message handle that was returned by MsgOpenMsg.
\par 
\par If the message was successfully closed, this function returns 0.  Otherwise, a value of -1 is returned, and msgapierr is set to: 
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1030{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }\pard\plain \s16\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f2\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {dword MsgReadMsg(MSGH *msgh, XMSG *msg, dword ofs, dword bytes, byte *text, dword cbyt, byte *ctxt);

\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\f4\fs20 
\par The MsgReadMsg function is used to read a message from disk.  This function can be used to read all parts of a message, including the message header, message body, and control information.
\par 
\par `msgh' is a message handle, as returned by the MsgOpenMsg function.  The message in question must have been opened with a mode of either MOPEN_READ or MOPEN_RW.
\par 
\par `msg' is a pointer to an XMSG (extended message) structure. The format of this structure is detailed below, but it contains all of the messa
ge information that is found in the message header, including the to/from/subject fields, origination and arrival dates, 4D origination and destination addresses, and so forth.  (See the appendices for specific information on the XMSG structure itself.)  
If the application wishes to read the header of a given message, this argument should point to an XMSG structure.  Otherwise, this argument should be NULL, which informs the API that the message header does not need to be read. 
\par 
\par `ofs' is used for reading m
essage text in a multiple-pass environment.  This defines the offset in the message body from which the API should start reading.  To start reading from the beginning of the message, a value of 0L should be given.  Otherwise, the offset into the message (
in bytes) should be given for this argument.  If the application does not wish to read the message body, this argument should be set to 0L. 
\par 
\par `bytes' represents the maximum number of bytes to read from the message.  Fewer bytes may be read, but the API will
 read no more than `bytes' during this call.  (See `text', and also this function's return value.)  If the application does not wish to read the message body, this argument should be set to 0L.
\par 
\par `text' is a pointer to a block of memory, into which the API 
will place the message body.  The message body will be read from the position specified by `ofs', up to a maximum of `bytes' bytes.  If the application does not wish to read the message body, this argument should be set to NULL.
\par 
\par `cbyt' represents the maximum number of bytes of control information to read from the message.
\par 
\par `ctxt' is a pointer to a block of memory, into which the API will place the message control information.  No more than `cbyt' bytes of control information will be placed into the buffer.
  NOTE: unlike the message text functions, control information can only be read in one pass. 
\par 
\par The text read by this function is free-form.  The message body may or may not contain control characters, NULs, or any other sequence of characters.  Messages are simply treated as a block of bytes, with no interpretation whatsoever.
\par 
\par In FidoNet areas, the message body consists of one or more paragraphs of text.  Each paragraph is delimited by a hard carriage return, '\\r', or ASCII 13.  Each paragraph can be of an
y length, so the text should be wordwrapped onto logical lines before being displayed.  If created by older applications, paragraphs may also contain linefeeds ('\\n') and soft returns ('\\
x8d') at the end of each line, but these are optional and should always be ignored.
\par 
\par As an example, assume that the following stream of text was returned by MsgReadMsg():
\par 
\par }{\b\f2\fs20 "Hi!\\r\\rHow's it going?  I got the new MsgAPI kit today!\\r\\rAnyhow, gotta run!"  
\par }{\f4\fs20 
\par The "\\r" marks are carriage returns, so they indicate the end of a par
agraph.  Notice that the second paragraph is fairly long, so it might have to be wordwrapped, depending on the screen width.  Your application might wordwrap the text to make it look like this, if using a window 40 characters wide: 
\par 
\par }{\b\f2\fs20   Hi!
\par 
\par   How's it going?  I got the new MsgAPI
\par   kit today!
\par 
\par   Anyhow, gotta run!
\par }{\f4\fs20 
\par Paragraphs should always be wordwrapped by the application, regardless of the screen/window size.  When parsing the message text, linefeeds and soft carriage returns should be simply skipped.
\par 
\par Th
e `message control information' has a somewhat more restricted format.  The control information is passed to the application in the form of an ASCIIZ string.  The control information is a variable-length string of text which contains information not found
 in the (fixed-size) message header.
\par 
\par The format of control information is given by the following regular expression:
\par 
\par (group)+<NUL>
\par 
\par A `group' consists of a <SOH> and a control item.
\par 
\par <SOH> is the Start Of Header character, or ASCII 01.  All control information strings must begin with an SOH, whether or not control items are present.
\par 
\par Following the <SOH> is a control item.  A control item consists of a string which describes the type of control item, or it may consist of nothing.
\par 
\par At least one group must be present in each message.  If a message has no extra control information, this field should consists of a <SOH> followed by a single <NUL>.
\par 
\par Although the control items are free-form, the following format is suggested:
\par 
\par <SOH>tag: value
\par 
\par ...where `tag' is a descriptive identifier, describing the type of field that the item represents.  `value' is simply free-form text, which continues up until the next SOH or <NUL>.
\par 
\par The character set for the tag and value consists of those characters in the range 2-255, inclusive.
\par 
\par As an example, a message might have the following control information: 
\par 
\par <SOH>CHARSET: LATIN1<SOH>REALNAME: Mark Twain<NUL>
\par 
\par The trailing <NUL> byte must be included in the read count given by `cbyt'.
\par 
\par The return value for this function is the number of bytes read from the message body.  If no characters were requested, this function returns 0. 
\par 
\par On error, the function returns -1 and sets msgapierr to one of the following:
\par 
\par MERR_BADH
\par MERR_BADF
\par MERR_NOMEM
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1031{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }\pard\plain \s16\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f2\fs20\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {sword MsgWriteMsg(MSGH *msgh, word append
, XMSG *msg, byte *text, dword textlen, dword totlen, dword clen, byte *ctxt);
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang3081\langfe1033\cgrid\langnp3081\langfenp1033 {\f4\fs20 
\par The MsgWriteMsg function is capable of writing the message header, body, and control information to a message.
\par 
\par `msgh' is a message handle, as returned by the MsgOpenMsg function.  The message must have been opened with a mode of MOPEN_CREATE, MOPEN_WRITE or MOPEN_RW.
\par 
\par `append' is a boolean flag, indicating the state of the message body.  If `append' is zero, then the API will write the message body starting at offset zero.  Oth
erwise, if `append' is non-zero, the API will continue writing from the offset used by the last MsgWriteMsg call.  This flag applies to the message body only; if no text is to be written to the body, this argument should be set to 0.
\par 
\par `msg' is a pointer to
 an XMSG structure.  If this pointer is non-NULL, then MsgWriteMsg will place the XMSG structure information into the message's physical header. To leave the header unmodified, NULL should be passed for `msg'.  THIS PARAMETER MUST BE PASSED THE **FIRST** 
TIME THAT MSGWRITEMSG() IS USED WITH A JUST-OPENED MESSAGE HANDLE! 
\par 
\par `text' points to an array of bytes to be written to the message body.  If no text is to be written, this argument should be NULL.
\par 
\par `textlen' indicates the number of bytes to be written to 
the message body in this pass of the MsgWriteMsg function.  The text is free-format, and it can consist of any characters, including NULs and control characters.  If the application does not wish to update the message body, a value of 0L should be passed 
for this argument.
\par 
\par `totlen' indicates the total length of the message to be written.  This differs from `textlen' in that the message may be written a piece at a time (using small `textlen' values), but the total length of the message will not exceed `totl
en'. This parameter can be somewhat restrictive for the application; however, this value is required for optimal use of some message base types.  The `totlen' value does not have to be the exact length of the message to write; however, space may be wasted
 
if this value is not reasonably close to the actual length of the message.  The rationale behind this argument is that it gives the API writer the most flexibility, in terms of supporting future message base formats.  If the application can provide this i
nformation to the API, then almost any message base format can be supported by simply dropping in a new API module or DLL.
\par 
\par To make multiple passes, the FIRST pass should call MsgWriteMsg with `append' set to 0, with the total length of the message in `totl
en', and the length of `text' in textlen.  Second and subsequent passes should set `append' to 1, with the length of `text' in textlen.
\par 
\par If the application does not wish to update the message body of an existing message, a value of 0L should be passed for this argument.  
\par 
\par This argument MUST be specified during the first call to the MsgWriteMsg when using a mode of MOPEN_CREATE, even if the first call is not requesting any text to be written. However, this value will be stored internally, and ignored on the
 second and later calls. 
\par 
\par When operating on a preexisting message (opened with MOPEN_WRITE or MOPEN_RW), it is an error to specify a length in `totlen' which is greater than the original length of the message. 
\par 
\par `clen' specifies the total length of the control information, including the trailing NUL byte.  To write no control information, a value of 0L should be passed for this argument.  
\par 
\par `ctxt' is a pointer to the control information string.  To write no control information, a value of 0L should be passed for this argument.  
\par 
\par N.B. Several restrictions apply to writing control information:  
\par 
\par First and foremost, control information can only be written once.  If the control information is to be changed, the message must be read and copied to another message.  
\par 
\par Secondly, control information MUST be written during or before MsgWriteMsg is called with information about the message body.  
\par 
\par MsgWriteMsg returns a value of 0 on success, or -1 on error. If an error occurred, msgapierr will be set to one of the following values:  
\par 
\par MERR_BADH
\par MERR_BADF
\par MERR_NOMEM
\par MERR_NODS
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1032{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgKillMsg(MSG *mh, dword msgnum);
\par }{\f4\fs20 
\par The MsgKillMsg function is used to delete a message from the specified message area.  
\par 
\par `mh' is a message area pointer, as returned by MsgOpenArea.
\par 
\par `msgnum' specifies the message number to kill.
\par 
\par It is an error to kill a message which is currently open.
\par 
\par MsgKillMsg returns a value of 0 if the message was successfully killed, or it returns -1 on error and sets msgapierr to one of the following:  
\par 
\par MERR_BADH
\par MERR_NOENT
\par MERR_BADF
\par MERR_NOMEM
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1033{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgLock(MSG *mh);
\par }{\f4\fs20 
\par The MsgLock function `locks' a message area for exclusive access.  This function may enable buffering or otherwise improve performance, so it is advised that MsgLock be called if speed is a concern when accessing the area.  
\par 
\par All of the MsgAPI functions automatically perform file locking and sharing internally, so this function is only required when high performance is necessary.  
\par 
\par `mh' is a message area pointer, as returned by the MsgOpenArea function.  
\par 
\par MsgLock returns 0 on success.  On error, MsgLock returns -1 and sets msgapierr to one of the following:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1034{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgUnlock(MSG *mh);
\par }{\f4\fs20 
\par The MsgUnlock function unlocks a previously-locked message area.  
\par 
\par `mh' is a pointer to a message area, as returned by MsgOpenMsg.  
\par 
\par MsgUnlock returns 0 on success, or it returns -1 on error and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1035{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgSetCurPos(MSGH *msgh, dword pos);
\par }{\f4\fs20 
\par The MsgSetCurPos function sets the `current position' in a message handle.  This position is used by MsgReadMsg to read text from the message body.  
\par 
\par `msgh' is a message handle, as returned by MsgOpenMsg.
\par 
\par `pos' is the number of bytes into the message from which MsgReadMsg should start reading.  
\par 
\par MsgSetCurPos returns 0 on success, or -1 on error and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1036{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetCurPos(MSGH *msgh);
\par }{\f4\fs20 
\par The MsgGetCurPos function retrieves the `current position' of a message handle.  This position is where the MsgReadMsg would read text from the message body next.  
\par 
\par `msgh' is a message handle, as returned by MsgOpenMsg.
\par 
\par MsgGetCurPos returns the offset into the message on success, or (dword)-1 on error and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1037{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 UMSGID MsgMsgnToUid(MSG *mh, dword msgnum);
\par }{\f4\fs20 
\par The MsgMsgnToUid function
 converts a message number to a `unique message ID', or UMSGID.  This function can be used to maintain pointers to an `absolute' message number, regardless of whether or not the area is renumbered or packed.  The MsgMsgnToUid function converts a message n
umber to a UMSGID,   and the MsgUidToMsgn function converts that UMSGID back to a message number. 
\par 
\par `mh' is the message area handle, as returned by MsgOpenArea.
\par 
\par `msgnum' is the message number to convert.
\par 
\par MsgMsgnToUid returns a UMSGID on success; otherwise, it returns 0 and sets msgapierr to:  
\par 
\par MERR_BADH
\par MERR_BADF
\par MERR_NOENT
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1038{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgUidToMsgn(MSG *mh, UMSGID umsgid, word type);
\par }{\f4\fs20 
\par The MsgUidToMsgn function converts a UMSGID to a message number.  
\par 
\par `mh' is the message area handle, as returned by MsgOpenArea.
\par 
\par `umsgid' is the UMSGID, as returned by a prior call to MsgMsgnToUid.  
\par 
\par `type' is the type of conversion to perform.  `type' can be any of the following values:  
\par 
\par UID_EXACT - Return the message number represented by the UMSGID, or 0 if the message no longer exists.  
\par 
\par UID_PREV - Return the message number represented by the UMSGID.  If the message no longer exists, the number of the preceding message will be returned.  
\par 
\par UID_NEXT - Return the message number represented by the UMSGID.  If the message no longer exists, the number of the following message will be returned.  
\par 
\par If no valid message could be found, MsgUidToMsgn returns 0 and sets msgapierr to one of the following:  
\par 
\par MERR_BADH
\par MERR_NOENT
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1039{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetHighWater(MSG *mh);
\par }{\f4\fs20 
\par The MsgGetHighWater function returns the `high water marker' for the current area.  This number represents the highest message number that was processed by a message export or import utility.  
\par 
\par `mh' is a message area handle, as returned by MsgOpenArea.
\par 
\par The high water marker is automatically adjusted when messages are killed.  
\par 
\par The MsgGetHighWater function returns the high water mark number on success, or 0 on error and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1040{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgSetHighWater(MSG *mh, dword hwm);
\par }{\f4\fs20 
\par The MsgSetHighWater function sets the `high water marker' for the current area.  
\par 
\par `mh' is a message area handle, as returned by MsgOpenArea.
\par 
\par `hwm' is the new high water marker to use for the specified area.  
\par 
\par The MsgGetHighWater function returns 0 on success, or -1 on error and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1041{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetTextLen(MSGH *msgh);
\par }{\f4\fs20 
\par The MsgGetTextLen function retrieves the length of the message body for the specified message.  
\par 
\par `msgh' is a message handle, as returned by MsgOpenMsg.
\par 
\par MsgGetTextLen returns the length of the body on success.  On error, it returns (dword)-1 and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1042{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetCtrlLen(MSGH *msgh);
\par }{\f4\fs20 
\par The MsgGetCtrlLen function retrieves the legnth of the control information for the specified message.  
\par 
\par `msgh' is a message handle, as returned by MsgOpenMsg.
\par 
\par MsgGetCtrlLen returns the length of the control information on success.  On error, it returns (dword)-1 and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1043{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par \page 
\par }{\b\f2\fs20 dword MsgGetCurMsg(MSG *mh);
\par }{\f4\fs20 
\par The MsgGetCurMsg function returns the number of the last message accessed with MsgOpenMsg.  
\par 
\par `mh' is a message area handle, as returned by MsgOpenArea.
\par 
\par MsgGetCurMsg returns the current message number on success, or 0 if there is no current message.  
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1044{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetNumMsg(MSG *mh);
\par }{\f4\fs20 
\par The MsgGetNumMsg function returns the number of messages in the current message area.  On error, MsgGetNumMsg returns (dword)-1 and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1045{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 dword MsgGetHighMsg(MSG *mh);
\par }{\f4\fs20 
\par The MsgGetHighMsg function returns the number of the highest message in the specified area.  On error, MsgGetHighMsg returns (dword)-1 and sets msgapierr to:  
\par 
\par MERR_BADH
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1046{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword MsgValidate(word type, byte *name);
\par }{\f4\fs20 
\par The MsgValidate function validates a particular message area, and determines whether or not the area exists and is valid.  
\par 
\par `type' is the type of the message area, using the same constants as specified for MsgOpenARea.  
\par 
\par `name' is the name of the message area, using the same format as specified for MsgOpenArea.  
\par 
\par MsgValidate returns the value 1 if the area exists and is valid.  Otherwise. MsgValidate returns 0.  
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1047{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword InvalidMsgh(MSGH *msgh);
\par }{\f4\fs20 
\par The InvalidMsgh function tests the given message handle for validity.  If the message handle is valid, a value of 1 is returned.  Otherwise, InvalidMsgh returns 0 and sets msgapierr to MERR_BADH.  
\par 
\par }{\f4\fs20 {\pict{\*\picprop\shplid1048{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 11450042}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn alignHR}{\sv 1}}{\sp{\sn dxHeightHR}{\sv 30}}
{\sp{\sn fStandardHR}{\sv 1}}{\sp{\sn fHorizRule}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex963\picscaley6\piccropl0\piccropr0\piccropt0\piccropb0\picw1764\pich882\picwgoal1000\pichgoal500\wmetafile8}}{\f4\fs20 
\par 
\par }{\b\f2\fs20 sword InvalidMh(MSG *mh);
\par }{\f4\fs20 
\par The InvalidMh function tests the given message area handle for validity.  If the message handle is valid, a value of 1 is returned.  Otherwise, InvalidMsgh returns 0 and sets msgapierr to MERR_BADH.  
\par 
\par }}
